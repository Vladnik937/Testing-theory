## Темы:

-  Что такое Тест дизайн

-  Техники черного ящика

-  Техники белого ящика

-  Техники основанные на опыте



## Тест-дизайн и Техники тест-дизайна

Проектирование теста (test design): Процесс перевода общих причин тестирования в конкретные тестовые условия и тестовые сценарии. (ISTQB)

Причина тестирования (test objective): Причина или цель разработки и выполнения теста. (ISTQB)

Тестовое условие (test condition): Объект или событие в компоненте или системе, которое должно быть проверено одним или несколькими тестовыми наборами. Например: функция, транзакция, свойство, атрибут качества или структурный элемент. (ISTQB)

Тест-дизайн - один из первоначальных этапов тестирования программного обеспечения, этап планирования и проектирования тестов.

Тест дизайн представляет собой продумывание и написание тестовых случаев (test case), в соответствии с требованиями проекта, критериями качества будущего продукта и финальными целями тестирования.

Цели:

Придумать тесты, которые обнаружат наиболее серьезные ошибки продукта. Да, мы можем придумывать тесты, которые находят несерьезные ошибки, но тогда тестирование будет неэффективным.

Минимизировать количество тестов, необходимых для нахождения большинства серьезных ошибок. Мы можем придумать столько тестов, сколько не в состоянии будем выполнить. Поэтому перед разработчиками тестов всегда стоит задача – сохранить эффективность тестов (то есть их способность обнаруживать серьезные ошибки) без увеличения их числа.

Задачи:

Проанализировать требования к продукту

Оценить риски возможные при использовании продукта

Написать достаточное минимальное количество тестов

Разграничить тесты на приемочные, критические, расширенные

Необходимые навыки:

Умение разделять систему на составляющие (делать декомпозицию). То есть, нужно уметь видеть систему как целое, но и уметь раскладывать ее на составные части. Это очень полезный навык для проведения функционального тестирования, где проверяется каждая фича продукта.

Умение собирать и анализировать требования к продукту. Если нет формально описанных требований – нужно уметь их собирать у разработчиков, у аналитиков, у пользователей

Умение расставлять приоритеты. Тест дизайнер должен уметь отличать более важное от менее важного, и расставлять приоритеты тестирования.

Умение формулировать свои мысли (письменно и устно). Это умение важно для тестировщика в принципе. Тест дизайнеру оно здорово поможет при создании тест кейсов.

Знание техник тест дизайна.

Умение применять их на практике.

Тест-дизайнер - Человек, который должен выстроить процесс тестирования всех важнейших частей продукта, используя минимально возможное количество проверок.

Техники тест-дизайна - это рекомендации, советы и правила, по которым стоит разрабатывать тест для проведения тестирования приложения. Это не образцы тестов, а только рекомендации к применению. В частности различные инженеры могут работая под одним и тем же проектом создать различный набор тестов. Правильным будет считаться тот набор тестов, который за меньшее количество проверок обеспечит более полное покрытие тестами.

План работы в тест-дизайне:

Анализ контекста и задач

Декомпозиция

Комбинаторика, Применение техник-тест дизайна

Проектирование и создание тест-кейсов

Анализ контекста и задач:

«Анализировать» означает -- спросить о том, зачем будущая программа вообще будет создана, как она была придумана, и почему она была придумана так, а не иначе. Затем уже можно начинать читать требования.Если об этом спросить ДО начала чтения требований, то требования вам будут понятны почти так же хорошо, как и тем, кто их написал.

У тестирования всегда есть какая-то метазадача, которую надо решить в принципе. Тест-дизайн -- это один из наилучших способов выяснить метазадачу и её реализацию.

Прояснение метазадачи тестирования выглядит следующим образом:

Понять, зачем что-то надо делать,

Потом осознать, что конкретно надо сделать,

Понять, как именно это надо сделать.

Open toolbar

Write a caption

**Декомпозиция**

Декомпозиция- процесс разбиения задачи на более мелкие.

Для QA декомпозиция обозначает то, что тестируемое приложение (отдельный его модуль или функционал) можно рассматривать как состоящий из относительно независимых друг от друга подсистем, каждую из которых тестировать гораздо проще и понятнее, чем всю систему сразу. В базовом понимании итоговым результатом декомпозиции будет набор параметров/требований, к которым мы в дальнейшем и будем применять техники тест дизайна, для определения конкретных проверяемых значений.

Целью на этом этапе для QA будет - подготовить список параметров и не потерять требования.

**Комбинаторика, применение техник:**

Комбинаторика -- это область математики, которая изучает комбинаторные структуры и методы для их анализа. Она занимается подсчетом, классификацией, перечислением и построением комбинаторных объектов, таких как перестановки, сочетания, разбиения, графы, деревья и многие другие.

Тестовые примеры выбираются на основе некоторого понятия покрытия, и цель стратегии комбинирования состоит в том, чтобы выбрать тестовые примеры из набора тестов таким образом, чтобы было достигнуто 100% покрытие.

Одним из основных преимуществ методов комбинаторного тестирования является экономия времени и ресурсов. Тестировщики могут использовать автоматизированные средства тест-дизайна: создания тестовых данных, что позволяет ускорить процесс тестирования и снизить затраты на тестирование. Однако, следует учитывать, что методы комбинаторного тестирования не являются универсальным решением для всех задач.

Нужно выбрать те техники тест дизайна, с помощью которых мы по каждому параметру, определим конкретные проверяемые значения. Итогом этой деятельности будет наличие условного чек-листа, где по каждому значению можно провести проверку. Уже на этом этапе мы одновременно должны учитывать ряд моментов, часть из которых в какой то мере могут конфликтовать между собой.

**Тестовое покрытие** Тестовое покрытие - одна из метрик оценки качества тестирования, представляющая из себя плотность покрытия тестами требований либо исполняемого кода.

Существуют следующие подходы к оценке тестового покрытия:

1. 1\.Покрытие требований - оценка покрытия тестами функциональных и нефункциональных требований к продукту путем построения матриц трассировки (traceability matrix);

2. 2\.Покрытие кода - оценка покрытия исполняемого кода тестами, путем отслеживания непроверенных в процессе тестирования частей программного обеспечения;

3. 3\.Тестовое покрытие на базе анализа потока управления - оценка покрытия, основанная на определении путей выполнения кода программного модуля и создания выполняемых тест-кейсов для покрытия этих путей.

Метод оценки покрытия кода не выявит нереализованные требования, так как работает не с конечным продуктом, а с существующим исходным кодом. Метод покрытия требований может оставить непроверенными некоторые участки кода, потому что не учитывает конечную реализацию.

Откуда получать информацию QA-специалисту

1. 1\.Бизнес-требования, спецификации, тех.дизайн, диаграммы процессов;

2. 2\.Беседа с аналитиком, менеджером, системным архитектором, заказчиком;

3. 3\.Беседа с разработкой.



## Техники белого ящика

Тестирование белого ящика -- это метод тестирования программного обеспечения, при котором тестировщики имеют доступ к исходному коду и могут использовать его для создания тестов. Основная цель -- проверить внутреннюю логику и структуру программы.

Основные методы тестирования белого ящика включают:

-  Покрытие операторов (statement coverage)

-  Покрытие решений (decision coverage)

-  Покрытие условий (condition coverage)

-  Оператор -- это любая отдельная команда в программе, которая выполняет определенное действие. Это может быть присвоение значения переменной, ввод/вывод данных, вызов функции и так далее.

Покрытие операторов: означает, что мы пишем тесты таким образом, чтобы каждый оператор в программе был выполнен хотя бы один раз.

-  Решения -- это логические конструкции, которые выбирают один из нескольких возможных путей выполнения программы в зависимости от условий. Наиболее распространенными примерами решений являются операторы if, else if и else, а также switch-выражения.

Покрытие решений: это тестирование программы таким образом, чтобы каждая ветвь решения была выполнена хотя бы один раз. Другими словами, нужно протестировать и истинную ветвь (например, P > 100), и ложную (например, P <= 100).

-  Условия -- это логическое выражение, которое возвращает либо true (истина), либо false (ложь). Условия используются в решениях для определения, какой путь выполнения программы выбрать.

Покрытие условий: это тестирование таким образом, чтобы каждая часть сложного условия (каждое подусловие) была проверена на истинность и ложность независимо от других частей условия.

## Техники черного ящика

## Эквивалентное разбиение

Эквивалентное разделение подразумевает разбиение тестовых данных на классы по какому-то признаку. Этот метод имеет смысл только в том случае, если компоненты чем-то похожи и могут войти в общую группу.

Если мы выбираем в качестве техники тест-дизайна эквивалентное разделение, это означает, что мы будем тестировать только несколько значений из каждого класса элементов. Помните, что это не гарантирует отсутствия ошибок в остальных значениях, не охваченных тестами. Мы лишь *предполагаем*, что использование нескольких элементов из каждой группы будет достаточно показательным.

Эквивалентное разделение -- хорошее решение для случаев, когда вы имеете дело с большим объемом входящих данных или множеством одинаковых вариантов ввода. В противном случае, возможно, имеет смысл более тщательно охватить продукт тестами.

#### **Пример эквивалентного разделения**

Допустим, есть интернет-магазин, который предлагает разные тарифы на доставку в зависимости от стоимости корзины. Например:

1. Стоимость доставки для заказов на сумму менее \$100 составляет \$15.

2. Стоимость доставки для заказов на сумму более \$100 составляет \$5.

3. При заказе от \$300 долларов доставка бесплатна.

У нас есть следующие ценовые категории для работы:

1. от \$1 до \$100.

2. от \$100 до \$300.

3. \$300 и выше.

При использовании техники эквивалентного разделения мы получаем три набора данных для тестирования:

**От \$1 до \$100:**

-   **допустимые значения:** любая цена в диапазоне от 1 до 99,99

-   **недопустимые значения:** любая цена ниже 1 или выше 99,99

**От \$100 до \$300:**

-   **допустимые значения:** любая цена в диапазоне от 100 до 299,99

-   **недопустимые значения:** любая цена ниже 100 или выше 299,99

**\$300 и выше:**

-  **допустимые значения:** любая цена выше 299,99;

-  **недопустимые значения:** любая цена ниже 300.

Таким образом, мы можем выбрать несколько чисел из каждого диапазона цен и предположить, что остальные числа из этих диапазонов будут давать такие же результаты.

### **Анализ граничных значений**

Анализ граничных значений в чем-то похож на эквивалентное разделение. Можно даже сказать, что оно лежит в основе анализа граничных значений. Но есть некоторые отличия.

При анализе граничных значений мы тоже группируем данные по эквивалентным классам, но проверяем не значения из определенного класса, а граничные значения -- те, которые находятся на «границах» классов. 

Эта логика применяется для интеграционного тестирования. Мы проверяем отдельные элементы во время юнит-тестирования, а на следующем уровне ошибки, скорее всего, появятся на «стыках» юнитов.

#### **Пример анализа граничных значений**

Возьмем предыдущий сценарий с различными тарифами на доставку. У нас те же данные, но другой подход к их использованию. Предполагая, что ошибки наиболее вероятны на границах диапазонов, мы тестируем только «граничные» числа:

**От \$1 до \$100:**

-  **допустимые граничные значения:** 1,00, 1,01, 99,99

-  **недопустимые граничные значения:** 0,99, 100,00, 100,01

**От \$100 до \$300:**

-  **допустимые граничные значения:** 100,00, 100,01, 299,99;

-  **недопустимые граничные значения:** 99,99, 300,00;

**\$300 и выше:**

-  **допустимые граничные значения:** 300,00, 300,01;

-  **недопустимые граничные значения:** 299,99.






