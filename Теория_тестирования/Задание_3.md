## Что такое функциональное тестирование и его виды

### Темы:

-  Что такое функциональное тестирование

-  По исполнению кода

-  По знанию системы

-  По уровням

-  По признаку позитивности сценариев

-  По времени и месту проведения

-  По подготовленности специалиста

-  По цени тестирования

-  По разработке тестовых сценариев

-  По степени автоматизации

-  По уровню представления системы


## Что такое функциональное тестирование и его виды

Функциональное тестирование (functional testing): Тестирование, основанное на анализе

спецификации функциональности компонента или системы. (ISTQB)

 Функциональное тестирование выполняется чтобы убедиться, что каждая функция программного

приложения ведет себя так, как указано в документе с требованиями.

Функциональное тестирование проверяет делает ли это приложение (сайт) то, что должен?

На примере интернет-магазина можно проверить такие функции и возможности:

● авторизацию;

● добавление товара в избранное и в корзину;

● оплату товара;

● заказ доставки;

● отмену заказа;

● добавление отзыва или вопроса и т.д.

Функциональное тестирование сосредоточено на проверке:

1. 1\.Ключевых функций

2. 2\.А также правильности обработки ошибок (то есть, выдает ли система сообщения об ошибках при их возникновении)

 Для функционального тестирования принято использовать две техники:

-  1\. На основе функциональных требований, указанных в спецификации требований. При этом для тестирования создаются тестовые случаи (testcases), составление которых учитывает приоритетность функций ПО, которые необходимо покрыть тестами

-  2\. На основе бизнес-процессов, которые должно обеспечить приложение. В этом случае, нас интересует не так работоспособность отдельных функций ПО, как корректность выполняемых операций, с точки зрения сценариев использования системы. Таким образом, тестирование в данном случае будет основываться на вариантах использования системы (usecases).





### По исполнению кода

#### Статическое

Статическое тестирование -- это процесс анализа программного кода, документации и других артефактов разработки без выполнения кода. Целью статического тестирования является выявление ошибок на ранних стадиях разработки, что позволяет сэкономить время и ресурсы.

Статическое тестирование может включать ревизию кода, проверку стиля кода, тестирование требований к системе и другие методы, которые позволяют проверить качество кода и документов без выполнения программы.

#### Динамическое

Динамическое тестирование -- это процесс проверки программного обеспечения путем его выполнения. Целью динамического тестирования является выявление ошибок в рабочем программном обеспечении и проверка его функциональности.

Обычно динамическое тестирование используется после статического тестирования, когда программный код уже был проверен на наличие очевидных ошибок.



### По знанию системы

#### Черный ящик

Тестирование черного ящика

Во время поведенческого тестирования или тестирования черного ящика, специалист не знает наверняка, что за продукт он тестирует. Внутренняя структура, приложение и дизайн остаются неизвестными для тестировщика. Тесты, как правило, функциональны. Веб-страницы изучаются с использованием браузера, вводом некоторых данных и при анализе полученных данных.

Метод черного ящика применим на следующих уровнях тестирования

-  Тестирование системы

-  Тестирование интеграции

-  Приемочных испытаниях

Количество методов тестирования зависит от сложности продукта, т.е. ящика.

Подходы к разработке алгоритмов тестирования черного ящика бывают следующие:

-  Причинно-следственные (определение случаев и их воздействия на систему)

-  Анализ крайних значений (определение границ ввода)

-  Разметка эквивалентности (действительные и недействительные разметки)

-  Когда мы работаем без возможности увидеть код, то можем предвидеть многие нестандартные пользовательские сценарии, так как не ограничены своим знанием об устройстве кода. Таким образом, не ждем от него только какого-то одного известного нам поведения. Разработчики часто подвержены когнитивным искажениям. Они знают, как устроен код и как должна работать программа. Но обычный пользователь -- человек непредсказуемый и часто может действовать не по сценарию. Так, банальная ошибка при вводе данных может полностью порушить парсинг.



#### Белый ящик

Главная цель этого процесса – проверка кода, тестирование как внутренней структуры, так и дизайна. Тестировщики могут видеть код на этой стадии, поэтому, этот метод имеет ряд других названий, таких как открытое тестирование или проверка кода. Каждый термин указывает на прозрачный процесс, как и возможность проверки процессов ввода-вывода, основываясь на внутренних алгоритмах работы.

Тестирование белого ящика предполагает поиск и улучшение следующих моментов:

-  Нерабочих или неоптимизированных участков кода

-  Потеря безопасности

-  Рабочие процессы и сценарии ввода

-  Условные процессы

-  Неправильное функционирование объектов

-  Некорректное отображения информации.

Подтверждение работоспособности системы приложения – цель тестирования белого ящика. Любое расхождение с ожидаемыми результатами может быть классифицировано как баг, нуждающийся в корректировке.

Как осуществляется тестирование белого ящика?

Есть два шага для реализации данного этапа.

Шаг 1. Изучение исходного кода.

Понимание исходного кода приложения - это отправная точка. Здесь тестировщик программного обеспечения должен продемонстрировать свои знания языков программирования. Другой неотъемлемый навык – понимание кода безопасности. Самая популярная причина тестирования программного обеспечения - это проверка надежности системы, поскольку многие веб-страницы и приложения собирают конфиденциальную информацию о пользователях. Приложение должно быть защищено от вредоносного ПО и хакеров, которые могут получить важные данные без предоставленных доступов.

Шаг 2. Создание и внедрение алгоритмов проверки

На этом уровне проверяются различные сценарии. Разрабатываются алгоритмы проверки, реализуются с целью выявления слабых мест. Здесь может иметь место и ручное тестирование.

Методы тестирования:

Основной подход – анализ кода. Выборка недоработок в процессе внедрения алгоритмов тестирования. Все алгоритмы запускаются по несколько раз на разных участках кода, помогая изъять возможные проблемные участки.

От тестировщика не требуется выполнения всего процесса вручную. Существует большое количество инструментов, которые помогут автоматизировать рабочий процесс и сохранить время.



#### Серый ящик

Тестирование серого ящика

-  Тестирование серого ящика предусматривает частичную осведомленность о внутренних процессах. Данный метод - это комбинация двух предыдущих подходов (тестирования белого и черного ящиков). Специалист стремится найти все проблемы функционирования и ошибки в коде. На этой стадии тестировщик может реализовать сквозной тест.

Подходы к тестированию

-  Тестирование шаблонов

-  Тестирование матрицы

-  Регрессионное тестирование

-  Тестирование с использованием ортогонального массива

Для запуска тестовых случаев во время тестирования серого ящика не обязателен доступ к коду. Каждый тест базируется на знании поведения программы. Это хороший подход к реализации функционального тестирования. Однако, это не будет успешным без реализации более глубоких методов, таких как тестирование белого и черного ящиков.





### По уровням

#### Unit тестирование

Модульное тестирование (или Unit test) – базовый уровень “пирамиды”. Модульные тесты проводят для отдельно взятых элементов или подпрограмм в коде. Как правило, юнит-тесты проводятся непосредственно разработчиками, позволяя на самом начальном этапе определить ошибки кода, возможные дефекты алгоритмов.



Модульное тестирование используется для тестирования какого-либо одного логически выделенного и изолированного элемента системы в коде. Целью тестирования модуля является не демонстрация правильного функционирования модуля, а демонстрация наличия ошибки в модуле, а также в определении степени готовности системы к переходу на следующий уровень разработки и тестирования. На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов. Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования.

Модульное тестирование имеет несколько преимуществ, среди которых можно выделить следующие:

Простота выполнения. Гораздо проще проводить тестирование на начальном этапе разработки под каждый отдельный модуль, нежели в дальнейшем тестировать весь продукт с нуля;

Возможность многоразового использования. Правильно прописанный тест можно будет использовать в дальнейшем;

Информативность. Unit-тест позволяет оценить API, функционал модулей и другие характеристики.

Также модульное тестирование позволяет разработчикам продолжать работу над другими компонентами приложений в то время, пока тестируется изолированный модуль.

Компонентное тестирование (или Component testing) – следующий более высокий уровень тестирования ІТ-продуктов. Он предполагает проведение тестирования для единиц (юнитов), объединенных в компоненты. При этом каждый из этих компонентов может тестироваться в индивидуальном порядке.

Компонентное тестирование занимает больше времени, чем модульное, поскольку компонент системы состоит из нескольких модулей. Хотя этот процесс может быть затратным по времени, он все равно необходим. Иногда отдельные модули работают исправно, но при их совместном использовании возникают проблемы.

Существует два вида компонентного тестирования: компонентное тестирование в малом и в целом.

-  Тестирование компонентов in small

При тестировании компонентов “в малом” каждый компонент проверяется отдельно от остальных компонентов системы. Чтобы протестировать компонент, нужно использовать имитации и макеты других компонентов, с которыми он взаимодействует. Такой вид тестирования гарантирует, что компонент готов к интеграции с остальной частью системы.

-  Тестирование компонентов in large

Компонентное тестирование “в широком плане” проводится без разделения, поэтому тестируемый компонент имеет доступ ко всем другим частям системы. При таком тестировании проверяется только главный компонент, а не связанные с ним модули или взаимодействие между ними.

(СЛАЙД) Чем отличается модульное тестирование от компонентного?

По сути, эти уровни тестирования весьма схожи между собой при единственном небольшом отличии – объеме исследуемых единиц. Т.е. компонентное тестирование дает возможность оценить уже готовые узлы и алгоритмы, а модульное – начальные единицы кода.

Модульные тесты создаются, чтобы проверить отдельные части кода, согласно плану разработки. Они помогают убедиться, что каждая часть программы работает правильно. Компонентные тесты, напротив, проводятся на уже собранных частях программы и используют реальные ситуации для проверки работы приложения в целом.

Модульные тесты запускаются разработчиком во время разработки ПО, чтобы он мог проверить, что каждый блок кода работает корректно. Когда все компоненты программы готовы, тестировщики или команда QA проводят компонентные тесты, чтобы убедиться, что все части программы работают вместе правильно и соответствуют требованиям.



#### Интеграционное тестирование

С ростом частоты релизов и обновления программного обеспечения у команды разработчиков возникает соблазн ускорить этап тестирования жизненного цикла разработки ПО. Но выпуск решений с ошибками может привести к негативному отношению со стороны конечных пользователей. Поэтому к каждому этапу тестирования следует подходить осознанно, особенно к тестированию интеграции.



Одним из этапов процесса обеспечения качества выступает интеграционное тестирование. Что такое интеграционное тестирование? Оно направлено на проверку взаимодействия между программными модулями для обеспечения их корректной совместной работы.

Цель интеграционного тестирования

Главная цель интеграционного тестирования -- подтвердить, что различные программные компоненты, модули и подсистемы работают вместе как единая система, обеспечивая требуемую функциональность и производительность.

Например, интеграционное тестирование позволяет выявить и решить проблемы, которые могут возникнуть при объединении нескольких компонентов: проблемы совместимости, производительности, некорректного взаимодействия или ошибок при обмене данными. Некоторые задачи интеграционного тестирования:

проверка взаимодействия модулей

обеспечение совместимости

раннее обнаружение проблем

повышение общей надежности системы

повышение качества ПО за счет выявления и устранения ошибок до того, как это станет более сложным и дорогостоящим процессом

Тестирование интеграции занимает значимое место в общем жизненном цикле разработки программного обеспечения, поэтому его нельзя пропускать при разработке ИТ-продукта.

Виды интеграционного тестирования

Выделяют несколько типов интеграционного тестирования, выполняемых для проверки взаимодействия между программными компонентами:

Интеграционное тестирование «большого взрыва»:

Этот вид тестов предполагает одновременную интеграцию всех программных модулей и их тестирование как целостной системы. Этот метод обычно используется в случаях, когда компоненты относительно независимы друг от друга и могут быть протестированы по отдельности.

Преимущества: благодаря такому подходу специалисты по контролю качества могут оценить всю систему сразу. Нет необходимости проводить отдельные тесты для каждого элемента.

Рекомендация: Применяя комплексный подход к тестированию интеграции, можно сэкономить время и ресурсы. Однако важно, чтобы каждый элемент теста был тщательно оценён до его полного внедрения.

Интеграционное тестирование сверху вниз:

Компоненты интегрируются и тестируются от самого высокого уровня к самому низкому. Этот подход используется в тех случаях, когда компоненты верхнего уровня зависят от компонентов нижнего уровня.

Преимущества: этот метод эффективен для тщательного изучения всей системы и последующего разбиения её на более мелкие части с целью выявления несоответствий.

Рекомендация: лучше всего подходит для компаний со сложной архитектурой ПО. Такая архитектура требует оценки многочисленных компонентов по отношению к основному модулю.

Интеграционное тестирование снизу вверх:

На этом этапе тестирования предполагается интеграция и тестирование модулей от самого низкого до самого высокого уровня.

Преимущества: метод позволяет получить всестороннюю оценку решения.

Рекомендация: тестируйте отдельные компоненты как единое целое, прежде чем интегрировать их в общую систему. Это необходимо для обеспечения бесперебойной работы решения.

Многослойное / гибридное интеграционное тестирование:

Такое интеграционное тестирование предполагает сочетание элементов нисходящего и восходящего интеграционного тестирования. Компоненты тестируются как с верхнего, так и с нижнего уровня, а для имитации отсутствующих компонентов используют заглушки и драйверы.

Преимущества: позволяет получить всеобъемлющий взгляд на функциональность.

Рекомендация: подходит для компаний, которым необходим как первичный обзор ПО сверху вниз, так и способ убедиться, что каждый нижний модуль выполняет свою задачу.

Непрерывное интеграционное тестирование:

Подход предполагает непрерывную интеграцию и тестирование компонентов по мере их разработки. Этот метод позволяет выявлять и устранять дефекты на ранних этапах разработки, повышая общее качество ПО и ускоряет процесс тестирования.

Преимущества: такой процесс тестирования позволяет убедиться в правильности интеграции каждого компонента перед переходом к следующему. Подход позволяет постоянно поддерживать качество решения и быстро вносить изменения при необходимости.

Рекомендации: это лучший вариант для компаний, которые желают оценить преимущества постепенной разработки без ущерба для процесса контроля качества.

Тип интеграционного тестирования зависит от конкретных требований к ПО, особенностей процесса разработки и от того, кто проводит интеграционное тестирование.

Как проводить интеграционное тестирование: примеры

Приведём пример тестового случая интеграции для интернет-магазина:

Название тестового примера: тест интеграции потока оформления онлайн-заказа.

Цель: протестировать интеграцию корзины для покупок, платёжного шлюза и системы управления заказами.

Необходимые условия:

Должен быть создан личный кабинет покупателя.

Клиент должен добавить в корзину минимум один товар из каталога.

Шаги:

Зайти в интернет-магазин в качестве покупателя

Перейти в корзину и убедиться, что в списке указаны правильные товары

Выбрать способ оплаты и ввести платёжную информацию

Нажать кнопку «Оформить заказ»

Убедиться, что платёж успешно обработан

Убедиться, что заказ отображается в системе управления заказами

Убедиться, что данные заказа, такие как товары, адрес доставки и способ оплаты верны

 Ожидаемые результаты:

Платёж должен быть успешно обработан

Заказ должен быть указан в системе управления заказами.

Детали заказа должны быть корректными

Этот интеграционный тест позволяет проверить, что различные компоненты интернет-магазина, такие как корзина, платёжный шлюз и система управления заказами, работают вместе корректно при обработке заказа.

Если все шаги теста выполнены правильно, это гарантирует, что покупатель сможет успешно завершить покупку и заказ будет правильно сформирован в системе. Чтобы достичь желаемых результатов тестирования, рекомендуем внедрять современные практики и инструменты интеграционного тестирования.

Лучшие практики интеграционного тестирования

Ниже приведены некоторые практики проведения эффективного интеграционного тестирования:

Интеграционное тестирование следует включить в план по обеспечению качества и внедрять на ранних этапах процесса разработки вместе с функциональными требованиями, чтобы обеспечить систематическую и всестороннюю интеграцию и тестирование системы.

Результаты интеграционных тестов должны контролироваться и отслеживаться, чтобы своевременно выявлять и устранять любые недостатки приложения и другого ПО.

Интеграционное тестирование требует сотрудничества между различными командами, такими как разработка, тестирование и техподдержка.

В ходе интеграционного тестирования должны быть проверены все возможные комбинации и сценарии, чтобы убедиться, что компоненты корректно работают вместе в различных условиях.

Тестирование API и инструменты интеграционного тестирования

Интеграционное тестирование тесно связано с тестированием API.

Тестирование API -- это один из подвидов тестирования программного обеспечения, в котором проверяется непосредственно интерфейс решения (API). API -- это компонент, который позволяет осуществлять связь между системой и другими частями приложения. API чаще всего представляет собой интерфейс, отделяющий внешних клиентов API от бэкенда и базы данных системы. Тесты API включают в себя проверку функциональности, надёжности, производительности и безопасности API.

Основные моменты в тестировании API:

Валидация запросов и ответов

Обработка ошибок

Аутентификация и авторизация

Тестирование производительности и нагрузки

Тестирование безопасности

Интеграция с другими API или системами

Взаимодействие и синхронизация

Комбинации параметров и граничные значения

Кэширование и согласованность данных

Управление версиями API и тестирование обратной совместимости

Инструменты для интеграционного тестирования API: Postman и SoapUI.

Ключевые различия интеграционного тестирования и тестирования API:

Тестирования API

Интеграционное тестирование

Тестирует функциональность и производительность API.

Тестирует взаимодействие между различными компонентами ПО.

Автоматизированное тестирование выполняется на ранних этапах цикла разработки.

Тестирование проводится после модульного тестирования и перед тестированием системы.

Фокусируется на поведении API для заданного входа.

Основное внимание уделяется тому, как различные модули или сервисы взаимодействуют друг с другом.

Обычно тестирует отдельные API изолированно.

Тестирует отдельные части системы. При этом могут проверяться API, база данных, бизнес-логика, интеграция с внешними ресурсами.

Применяется только для тестирования API, являющейся частью более крупной системы.

Может использоваться для тестирования широкого спектра приложений, включая настольные, веб- и мобильные приложения.

Заключительные мысли

Тестирование программного обеспечения выступает одним из основных этапов цикла разработки. В рамках этого процесса интеграционное тестирование выделяется как одно из наиболее значимых звеньев.

Интеграционное тестирование, интегрированное в проект, позволяет убедиться, что продукт соответствует функциональным требованиям и работает так, как ожидалось. Оно позволяет выявить критические дефекты на ранних этапах разработки, прежде чем исправление ошибок станет более сложным и дорогостоящим. Выявление и устранение проблем совместимости, потоков данных и взаимодействия между компонентами повышает общее качество ПО.

Интеграционное тестирование повышает доверие к продукту за счёт проверки того, что вся система работают как единое целое и обеспечивают пользователям заявленную функциональность. В целом, проведение интеграционного тестирования -- фактор того, что вы поставляете на рынок качественные и стабильные программные решения.



#### Системное тестирование

Системное тестирование -- это процесс проверки готового программного обеспечения, чтобы убедиться, что оно работает так, как задумано. Это финальная проверка перед тем, как программа попадет к пользователям.



Зачем нужно системное тестирование?

Проверка работы всей системы: Мы смотрим, как все части программы работают вместе. Иногда отдельные части могут работать хорошо, но в совокупности могут возникнуть проблемы.

Выявление ошибок: Системное тестирование помогает находить ошибки и недочеты, которые могли быть упущены на предыдущих этапах разработки.

Удовлетворение пользователей: Мы проверяем, соответствует ли программа ожиданиям пользователей. Если программа удобна и понятна, пользователи будут довольны.

Как это происходит?

Тестировщики: Команда тестировщиков запускает программу и проверяет, как она работает, используя разные сценарии.

Разные виды тестов: Системное тестирование включает в себя:

-  Проверку функциональности.

-  Тестирование производительности.

-  Проверку безопасности.



Почему это важно?

Системное тестирование помогает создать качественный продукт, который будет надежным и удобным для пользователей. Это снижает риск появления проблем после запуска программы и повышает доверие к продукту. Таким образом, системное тестирование -- это ключевой этап, который помогает сделать программное обеспечение лучше и безопаснее для пользователей.



#### Приемочное тестирование

Виды приемочного тестирования:

-  Пользовательское приемочное тестирование (UAT - User Acceptance Testing, validation, end-user testing) выполняется пользователем или клиентом чтобы определить, может ли ПО быть принято (accepted) или нет и проверить ПО на соответствие бизнес-требованиям. Могут существовать такие бизнес-требования и процессы, которые известны только конечным пользователям, и они либо пропускаются, либо неправильно интерпретируются, поэтому приемочное тестирование выполняется конечными пользователями, знакомыми с бизнес-требованиями;
-  Бизнес - приемочное тестирование (BAT - Business Acceptance Testing) необходимо для оценки того, соответствует ли Продукт бизнес-целям и задачам. BAT в основном фокусируется на бизнес-преимуществах (финансах), которые являются довольно сложными из-за меняющихся рыночных условий / прогрессирующих технологий, так что текущая реализация может претерпеть изменения, которые приведут к дополнительным затратам. Даже Продукт, отвечающий техническим требованиям, может не пройти BAT по этим причинам;
-  Контрактное приемочное тестирование (CAT - Contract Acceptance Testing) - это контракт, который определяет, что после того, как Продукт будет запущен в течение заранее определенного периода, должен быть проведен приемочный тест, и он должен пройти все приемочные тест-кейсы. Подписанный здесь контракт называется Соглашением об уровне обслуживания (SLA), которое включает условия, по которым платеж будет производиться только в том случае, если услуги Продукта соответствуют всем требованиям, что означает, что контракт выполнен. Иногда этот контракт может заключаться до того, как Продукт будет запущен. В любом случае, контракт должен быть четко определен с точки зрения периода тестирования, областей тестирования, условий по проблемам, возникающим на более поздних этапах, платежей и т. д.;
-  Правовое приемочное тестирование (RAT - Regulations/Compliance Acceptance Testing) необходимо для оценки того, нарушает ли Продукт правила и нормы, установленные правительством страны, в которой он выпускается. Это может быть непреднамеренным, но отрицательно скажется на бизнесе. Обычно разрабатываемый Продукт / приложение, предназначенный для выпуска во всем мире, должен пройти RAT, поскольку в разных странах / регионах действуют разные правила и положения, определенные его руководящими органами. Если какие-либо правила и нормы нарушаются для какой-либо страны, то этой стране или конкретному региону в этой стране не будет разрешено использовать Продукт и это будет считаться отказом (Failure). Вендоры Продукта несут прямую ответственность, если Продукт будет выпущен даже при наличии нарушения;
-  Эксплуатационное приемочное тестирование (OAT - Operational Acceptance testing) - это тип тестирования программного обеспечения, который оценивает эксплуатационную готовность программного приложения до его выпуска в производство. Целью эксплуатационного тестирования является обеспечение бесперебойной работы системы в ее стандартной эксплуатационной среде (SOE - standard operating environment). В основном это тестирование восстановления, совместимости, ремонтопригодности, доступности технической поддержки, надежности, восстановления после сбоя, локализации и т. д (recovery, compatibility, maintainability, technical support availability, reliability, fail-over, localization);

#### Примеры сценариев приемочного тестирования:

1. 1\.Функциональные тесты: Проверка ключевых функций продукта, чтобы убедиться, что они работают в соответствии с требованиями

2. 2\.Тестирование пользовательских интерфейсов (UI): Оценивается удобство использования, корректность отображения элементов интерфейса, а также взаимодействие пользователя с системой

3. 3\.Производительность: Проверяется, соответствует ли производительность системы установленным требованиям при типичных и максимальных нагрузках

4. 4\.Тестирование безопасности: Проверка соответствия продукта требованиям безопасности, в том числе защите данных и предотвращению несанкционированного доступа



### По признаку позитивности сценариев

#### Позитивное тестирование

Позитивное тестирование – это тестирование с применением сценариев, которые соответствуют нормальному (штатному, ожидаемому) поведению системы. С его помощью мы можем определить, что система делает то, для чего и была создана.

Позитивное тестирование -- это подход, при котором проверяются функциональные возможности системы на правильность работы в условиях корректного использования. Создание позитивных тест-кейсов является важным этапом при разработке и тестировании программного обеспечения. Он позволяет проверить работу системы в условиях правильного использования и предотвратить возможные ошибки, которые могут возникнуть при ее эксплуатации.

Особенности:

-  Цель: Демонстрация того, что продукт работает по назначению и выполнен согласно требованиям и спецификациям.

-  Входные данные: Используются только валидные и корректно оформленные данные, которые ожидаются в реальной эксплуатации системы.

-  Результаты: Ожидается, что система успешно обработает данные и выполнит соответствующие функции без ошибок.

Эта методика является важной частью процесса тестирования, поскольку она направлена на подтверждение основного функционала и удобства использования продукта. Однако для полного тестового покрытия позитивное тестирование должно дополняться негативным тестированием, которое проверяет поведение системы при вводе некорректных данных или выполнении нестандартных действий пользователем.



#### Негативное тестирование

Негативным называют тестирование, в рамках которого применяются сценарии, которые соответствуют внештатному поведению тестируемой системы. Это могут быть исключительные ситуации или неверные данные.

Надежность приложения может быть оценена только с помощью эффективно разработанных негативных сценариев. Негативное тестирование выявляет потенциальные дефекты в приложении, которые могут серьезно повлиять на использование продукта в целом. Также такое тестирование может быть полезным для определения условий, при которых приложение может дать сбой.

Основные аспекты:

Обработка невалидных данных: Проверка реакции системы на ввод данных, выходящих за пределы ожидаемых значений, форматов или диапазонов.

Тестирование граничных условий: Включает в себя ввод значений на границе или вне допустимых пределов для выявления потенциальных проблем в обработке краевых случаев.

Проверка обработки исключений: Оценка способности системы корректно обрабатывать ошибочные ситуации, например, отсутствие необходимых файлов, ошибки доступа к ресурсам и т. д.

Тестирование на переполнение: Ввод слишком больших значений или объемов данных для проверки устойчивости системы к переполнениям и утечкам памяти.

Использование неподдерживаемых операций: Попытки выполнения действий, которые не должны быть доступны или разрешены в текущем контексте работы приложения.

Пример:

В первом окне пользователь должен ввести текстовые значения:

Требования:

-  Текстовое поле “Name” является обязательным.

-  “Description” не является обязательным.

-  Поле “Name” может содержать только символы a-z и A-Z. Цифры и специальные символы не допускаются.

-  Длина поля “Name” – не более 10 символов.

Позитивные сценарии тестирования:

1. 1\.ABCDEFGH (проверка верхнего регистра в пределах лимита символов).

2. 2\.abcdefgh (проверка нижнего регистра в пределах лимита символов).

3. 3\.aabbccddmn (проверка лимита символов).

4. 4\.aDBcefz (проверка сочетания букв в верхнем и нижнем регистре в пределах лимита символов).

5. 5\.… и так далее.

Негативные сценарии тестирования:

1. 1\.ABCDEFGHJKIOOOOOKIsns (превышение лимита в 10 символов для поля “Name”)

2. 2\.abcd1234 (числовые значения, введенные в поле “Name”)

3. 3\.В поле “Name” ничего не введено

4. 4\.sndddddwwwww\_ (специальные символы в поле “Name”)

5. 5\.… и так далее.

Для выбора эффективных тест-кейсов, которые охватывают все возможные сценарии, применяются две техники:

-  Анализ граничных значений

-  Разделение эквивалентности

**Анализ граничных значений:**

Это один из методов тестирования программного обеспечения, в котором тестовые сценарии включают в себя граничные значения. Если входные данные используются в пределах граничных значений, то это называется положительным тестированием. Если входные данные выбираются за пределами граничных значений, то это называется отрицательным тестированием.Основная идея этого подхода состоит в следующем -- нужно выбрать значения входных переменных на их:

-  минимуме

-  чуть выше минимума

-  номинальном значении

-  чуть ниже максимума

-  максимуме

Разделение эквивалентности: Эквивалентное разделение (Equivalence Partitioning, EP) – это стратегия тестирования программного обеспечения, которая помогает повысить эффективность тестовых случаев. Она основана на идее разделения входных данных на группы, внутри которых значения считаются эквивалентными для целей тестирования.Суть техники эквивалентного разбиения в том, чтобы:

-  Разделить данные на группы (классы эквивалентности), которые, как предполагается, обрабатываются системой схожим образом (то есть ведут систему к одному состоянию);

-  Из каждой группы (класса) выбрать одно значение и проверить его.

Мы предполагаем, что каждое значение в одном классе обрабатывается системой одинаково. Таким образом нам достаточно проверить только одно значение из класса, чтобы подтвердить, что все значения внутри класса будут работать.



### По месту и времени проведения

#### Альфа тестирование

Альфа тестирование действительно проводится на мощностях компании-разработчика, и его цель -- ранняя проверка продукта. Тестирование проходит в контролируемой среде, часто в лабораторных условиях, но также может включать ограниченное количество пользователей вне команды разработчиков, таких как:

-  **Фокус-группы**: Внешние пользователи, которые специально приглашаются для тестирования. Эти пользователи дают ценную обратную связь, взаимодействуя с продуктом на ранней стадии.

-  **Внутренние сотрудники компании**: В том числе не только разработчики и тестировщики, но и другие отделы компании (например, маркетинг, поддержка).

Это этап тестирования помогает команде сосредоточиться на выявлении критических ошибок, сбоев системы, проблем с производительностью и стабильностью приложения. Однако реальная пользовательская среда на этом этапе не всегда учитывается.

#### Бета тестирование

Бета тестирование проводится за пределами компании-разработчика. На этом этапе продукт передается реальным пользователям, которые тестируют его в условиях, максимально приближенных к тем, в которых он будет использоваться после релиза. Эти пользователи могут быть:

-  **Конечные пользователи**: Обычные потребители, которые тестируют продукт в реальных условиях эксплуатации. Они не связаны с компанией, и их опыт позволяет обнаружить проблемы, связанные с разнообразием пользовательских устройств, операционных систем и других условий.

-  **Приглашенные пользователи**: Иногда разработчики приглашают конкретные группы пользователей или организации для бета тестирования.

Бета тестирование позволяет выявить баги, связанные с реальными условиями эксплуатации, взаимодействием с различными устройствами, сетевыми конфигурациями и другими факторами, которые трудно смоделировать на этапе альфа тестирования.


### По подготовленности специалиста

#### Интуитивное  (Ad-hoc) тестирование

Свободное тестирование (ad hoc testing): Тестирование, выполняемое неформально; без формальной подготовки тестов, формальных методов проектирования тестов, определения ожидаемых результатов и руководства по выполнению тестирования. (ISTQB).

Чаще всего такое тестирование выполняется, когда владелец продукта не обладает конкретными целями, проектной документацией и ранее поставленными задачами. При этом тестировщик полагается на свое общее представление о продукте, сравнение с похожими продуктами, собственный опыт.

#### Преимущества ad-hoc тестирования

Основное преимущество ad-hoc тестирования -- возможность выявить баги, которые остались бы незамеченными при других проверках. А поскольку для такого тестирования не нужно ничего планировать и структурировать, оно экономит много времени.

Дополнительный плюс ad-hoc тестирования -- тестировщик проводит его в свободной форме, согласно своему пониманию системы. Он может добавлять различные проверки уже по ходу работы, что помогает выявлять ошибки.

Такое тестирование могут проводить и сами разработчики ПО.

#### Недостатки ad-hoc тестирования

Основной недостаток ad-hoc тестирования состоит в том, что сам процесс тестирования не документируется, поскольку идет не по конкретному набору тест-кейсов. В результате воспроизвести замеченную ошибку сложнее. Для этого тестировщику приходится вспоминать, какие шаги привели его к нужной точке.

Кроме того, если у тестировщика нет предварительных знаний о функционале тестируемого приложения, ad-hoc тестирование будет бесполезным, оно не выявит никаких ошибок.

Тестирование ad-hoc имеет смысл только в случае, если тестировщик владеет общей информацией о продукте. Если человек совсем не будет знать продукт, то потратит время на его изучение, особенно если проект очень сложный и большой. Поэтому нужно хорошее представление о целях проекта, его назначению и основным функциям и возможностям. А дальше уже можно приступать к ad-hoc testing.

#### Виды Ad hoc тестирования:

buddy testing (совместное тестирование) -- когда 2 человека, как правило, разработчик + тестировщик, работают параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает тестировщику выполнять необходимые проверки, а программисту фиксить баги на ранних этапах.

pair testing (парное тестирование) -- когда 2 тестировщика проверяют один модуль и помогают друг другу. К примеру один может искать дефекты, а второй их документировать. Таким образом у одного тестера будет функция, скажем так, обнаружителя, у другого -- описателя

Monkey testing - произвольное тестирование продукта с целью как можно быстрее, используя различные вариации входных данных, нарушить работу программы или вызвать ее остановку (простыми словами - сломать);

MonKey testing похоже на Ad hoc Testing. Это также проводится случайным образом, без какого-либо планирования или подготовки. По этой причине многие программисты относят Monkey Testing к типу Adhoc Testing. Однако Monkey Testing отличается от Adhoc Testing одним существенным образом, Monkey Testing можно проводить без каких-либо знаний или информации о программном обеспечении..



### Исследовательское (Exploratory) тестирование

Исследовательское Тестирование - одновременно является и техникой, и видом тестирования.

Exploratory testing подразумевает под собой одновременно изучение проекта, функционала, тест-дизайн в уме и тут же исполнение тестов, после чего данный цикл может повторяться необходимое количество раз, каждый раз улучшая создаваемые кейсы и документируя пройденные сессии. Подход к тестированию, при котором тестировщики одновременно изучают приложение, проектируют и выполняют тесты.

Особенности:

✅Тестирование основано на постоянном обучении. Тестировщик начинает с ограниченного понимания системы и расширяет свои знания в процессе тестирования.

✅Тестовые сценарии разрабатываются в процессе тестирования, что делает исследовательское тестирование гибким и адаптивным.

✅Подход особенно эффективен для выявления сложных и неочевидных ошибок.

Преимущества:

✅Повышает качество тестирования за счёт использования творческого подхода и аналитических способностей тестировщика.

✅Позволяет быстро адаптироваться к изменениям в приложении и требованиям.

Отличия:

✅Структурированность: В отличие от Ad Hoc Testing, исследовательское тестирование требует, чтобы тестировщик активно использовал свои знания для проектирования тестов во время самого тестирования, делая процесс более организованным.

✅Целенаправленность: Исследовательское тестирование направлено на активное обучение и понимание системы, в то время как Ad Hoc Testing может быть более случайным и спонтанным.

✅Документация: Исследовательское тестирование часто включает в себя создание кратких заметок о проведённых тестах и обнаруженных ошибках для последующего анализа и улучшения процесса тестирования, тогда как в Ad Hoc Testing документация может отсутствовать.

{% table %}

---

*  **Row options**

   #### **Исследовательское тестирование (Exploratory Testing)**

*  **Свободное тестирование (Ad-hoc Testing)**

---

*  Row options

   Исследовательское тестирование более структурированное. Обычно тестировщик знает, что ему нужно проверить, у него в голове есть цель и какая-то система проведения тестов. Хоть тесты в этом случае не обязательно должны быть оформлены в виде тест кейсов.

*  Ad-hoc testing -- это более интуитивное и беспорядочное тестирование, когда тестировщик просто идет и проверяет, что ему хочется. У него нет определенной цели, структуры тестов в голове, какой-то системы.

---

*  Row options

   у вас есть требования или общее понимание работы продукта, вы набросали первичные проверки, которые будете дорабатывать по ходу тестирования.

*  у вас могут быть требования или полностью отсутствовать, вы не создаете набросок тестирования или официальную документацию, а тестируете приложениe основываясь только на свой опыт.

{% /table %}

Оба эти подхода ценны в арсенале тестировщика, позволяя гибко подходить к поиску и устранению ошибок в программном обеспечении.



### Monkey тестирование и Gorilla тестирование.

Monkey testing – это метод тестирования при разработке программного обеспечения, при котором QA инженер предоставляет приложению случайные входные данные без использования каких-либо тестовых примеров, которые могут привести к сбою системы. Этот метод применяется ко всей системе и используется для обнаружения ошибок, которые трудно обнаружить традиционными методами тестирования.



#### Преимущества Monkey Testing

Monkey Testing имеет множество преимуществ:

Отсутствуют заранее определенные тест-кейсы, все входные данные случайны.

Это автоматизированное тестирование с возможностью интеграции с популярными инструментами.

Не требует планирования или подготовки.

Тестировщику, выполняющему это тестирование, не нужно обладать полным знанием всех деталей приложения.

Требует меньше времени и усилий.

Используется для проверки надежности и производительности системы.

Что такое Gorilla Testing?

Gorilla Testing похоже на Monkey Testing, но в первом методе тестируются отдельные модули, в то время как при втором методе проверяется вся система в целом. Выбирается каждый модуль продукта, и в него случайным образом подаются действительные и недействительные входные данные до тех пор, пока модуль не выйдет из строя. Это скрупулезный ручной тест для проверки надежности приложения.

Особенности Gorilla Testing

Основные преимущества Gorilla Testing:

В нем используются случайные входные данные и тесты.

Это тщательный повторяющийся процесс ручного тестирования.

Не требует заранее определенных тестовых случаев.

Используется для проверки надежности модуля.

Он специфичен для конкретного модуля и неукоснительно тестирует каждый модуль перед переходом к следующему.

Для тестирования модуля требуется определенная подготовка.

Monkey Testing vs Gorilla Testing: Использование

Monkey Testing используется для проверки производительности приложения. Оно подходит для нагрузочного тестирования ПО путем предоставления случайных входных данных с целью сломать приложение. Бывают случаи, когда некоторые ошибки трудно выявить традиционными способами тестирования. Предоставление случайных входных данных повышает вероятность обнаружения таких ошибок.

При Gorilla testing берется каждый крошечный кусочек кода и тщательно тестируется с использованием случайных входных данных до тех пор, пока он не разрушится. Этот шаг выполняется для каждого модуля в приложении, чтобы проверить его надежность. Из-за такого жестокого характера тестирования его также называют тестированием на пытки или тестированием на отказоустойчивость. Обычно оно проводится на последних этапах цикла разработки программного обеспечения, чтобы убедиться, что все модули приложения работают так, как ожидалось.

<https://www.automationtestinginsider.com/search/label/Monkey%20Vs%20Gorilla%20Testing>

<https://qarocks.ru/monkey-vs-gorilla-testing/>

Monkey Testing

Gorilla testing

\- это тип тестирования программного обеспечения, который выполняется на основе некоторых случайных входных данных без каких-либо тестовых примеров и проверяет поведение системы и подтверждает, происходит ли сбой или нет.

\- это тип тестирования программного обеспечения, который многократно выполняется в модуле на основе некоторых случайных входных данных и проверяет функциональность модуля и подтверждает отсутствие ошибок в этом модуле.

При обезьяньем тестировании для тестирования приложения не используется тестовый пример, поскольку это часть случайного тестирования.

Оно выполняется неоднократно, поскольку является частью ручного тестирования.

Подход Monkey Testing в основном используется при системном тестировании.

Подход к тестированию Gorilla в основном используется в модульном тестировании.

Обезьянье тестирование реализовано в целой системе.

Тестирование Gorilla реализовано на нескольких отдельных компонентах системы.

Для выполнения обезьяньего тестирования не требуется никаких знаний в области программного обеспечения.

Для выполнения тестирования gorilla требуются минимальные знания в области программного обеспечения.

Основная цель Monkey Testing - проверить, происходит ли сбой системы или нет.

Основная цель тестирования Gorilla - проверить, работает ли модуль должным образом или нет.

Обезьянье тестирование также известно как случайное тестирование, нечеткое тестирование или стохастическое тестирование.

Тестирование гориллой также известно как Мучительное тестирование, тестирование на отказоустойчивость или Разочаровывающее тестирование.

Существует три типа обезьяньего тестирования: тестирование тупой обезьяной, тестирование умной обезьяной и тестирование блестящей обезьяной.

Пока таких различных типов тестирования гориллой не существует.

Внедрение Monkey testing не требует какого-либо планирования или подготовки.

Тестирование Gorilla не может быть реализовано без какой-либо подготовки или планирования.

По времени и месту проведения

 Альфа тестирование (Alpha testing)

 Бета тестирование (Beta testing)

 (Классификация по привлечению конечных пользователей)

Альфа-тестирование и бета-тестирование обычно используются разработчиками готовых коммерческих решений, которые хотят получить обратную связь от потенциальных или существующих пользователей, клиентов и/или операторов до того, как программный продукт будет выставлен в коммерческую продажу.

Согласно ISTQB-CTFL_Syllabus_2018_v3.1.1 альфа и бета тестирование относят к видам приемочного (Acceptance) тестирования, наряду с: Пользовательское приемочное тестирование (User acceptance testing) ● Эксплуатационное приемочное тестирование (Operational acceptance testing) ● Контрактное и нормативное приемочное тестирование (Contractual and regulatory acceptance testing).

{% table %}

---

*  **Row options**

*  **Альфа**

*  **Бета**

---

*  Row options

   Где?

*  Внутри компании, на мощностях компании разработчика

*  Вне компании, на собственных мощностях тестирующих

---

*  Row options

   Кем?

*  не командой самого разработчика, а потенциальными или существующими клиентами и/или операторами или независимой группой тестирования

*  потенциальными или существующими клиентами и/или операторами

---

*  Row options

   Среда (environment)

*  Разработческая среда (Development Environment): Первоначальное тестирование может проводиться в среде разработки, где код разрабатывается и запускается.

   Тестовая среда (Testing/Staging Environment): Более продвинутое альфа-тестирование обычно проводится в изолированной тестовой среде, которая имитирует реальную рабочую среду, но с ограниченным набором данных и конфигураций.

*  Предпродажная среда (Pre-production Environment): распространяется через специальный канал, например, бета-магазин приложений или через систему раннего доступа. Эта среда практически идентична реальной производственной среде.

   Реальная среда (Production Environment): В некоторых случаях бета-версии могут быть доступны в реальной производственной среде, но с пометкой "бета", чтобы пользователи понимали, что это не окончательная версия.

---

*  Row options

   Устройства

*  Внутренние устройства разработчиков: Это могут быть компьютеры, виртуальные машины или тестовые серверы, используемые непосредственно разработчиками и внутренними тестировщиками.

   Тестовые устройства: В некоторых случаях компании используют специальные тестовые устройства или эмуляторы, чтобы проверить работу приложения на различных конфигурациях и платформах (например, разные версии операционных систем, разрешения экрана и т.д.).

*  Устройства пользователей: Бета-тестирование проводится на реальных устройствах пользователей, которые согласились участвовать в тестировании. Это могут быть смартфоны, планшеты, компьютеры, игровые консоли и другие устройства, которые соответствуют требованиям приложения.

   Разнообразные платформы и конфигурации: Важно, чтобы бета-тестирование охватывало широкий спектр устройств и конфигураций, чтобы выявить проблемы, которые могут возникнуть у различных пользователей.

---

*  Row options

   Главные задачи

*  1. 1\.Проверка функциональности и стабильности приложения.

   2. 2\.Поиск критических багов.

   3. 3\.Проверка интеграции разных модулей приложения.

*  1. 1\.Проверка работы приложения в реальных условиях.

   2. 2\.Оценка пользовательского опыта.

   3. 3\.Выявление ошибок, которые не были найдены на стадии альфа-тестирования.

   4. 4\.Сбор отзывов от пользователей для возможных улучшений перед окончательным релизом.

{% /table %}

#### Пользователи

Пользователи -- это те, кто непосредственно взаимодействует с программным обеспечением, используя его для выполнения своих задач. Они могут быть конечными пользователями, которые используют продукт в личных или профессиональных целях. Например, если это программное обеспечение для редактирования фотографий, пользователи -- это люди, которые будут работать с фотографиями с его помощью.

#### Клиенты

Клиенты -- это те, кто приобретает программное обеспечение или платит за его использование. Они могут быть как индивидуальными пользователями, так и организациями, которые покупают ПО для использования в своей работе. Клиенты не всегда являются прямыми пользователями продукта; например, компания может приобрести лицензии на программное обеспечение для своих сотрудников, которые будут его использовать.

#### Операторы

Операторы -- это люди, которые управляют, поддерживают или обслуживают программное обеспечение, но не обязательно являются его пользователями в повседневной работе. Они могут быть системными администраторами, техническими специалистами, которые отвечают за установку, настройку, мониторинг и поддержание стабильной работы программного обеспечения. Например, в случае с корпоративным ПО операторы могут следить за его работой на серверах и обеспечивать его бесперебойное функционирование.

#### В контексте тестирования

-  Пользователи в контексте альфа и бета тестирования -- это те, кто будет использовать продукт и может предоставить обратную связь о его удобстве, функциональности и общей пригодности для решения задач.

-  Клиенты могут дать обратную связь о том, насколько продукт соответствует их ожиданиям с точки зрения качества и ценности для бизнеса.

-  Операторы могут оценить, насколько удобно поддерживать и администрировать программное обеспечение, его совместимость с другими системами, стабильность и производительность.

\[Куликов\] Гамма-тестирование (gamma testing) -- финальная стадия тестирования перед выпуском продукта, направленная на исправление незначительных дефектов, обнаруженных в бета-тестировании. Как правило, также выполняется с максимальным привлечением конечных пользователей/заказчиков. Может являться формой внешнего приёмочного тестирования . Суть этого вида вкратце: продукт уже почти готов, и сейчас обратная связь от реальных пользователей используется для устранения последних недоработок.

## По цели тестирование

### Дымовое (Smoke) тестирование

Смоук-тестирование -- это минимальный набор тестов, который проверяет основные функции системы или компонента. Задача – проверить, работает ли система в общих чертах, без детальной проверки.

Когда и почему применяется смоук-тестирование

Дымное-тестирование проверяет систему на условное «возгорание», сразу после ее установки или изменений и перед запуском, чтобы убедиться, что основные функции работают исправно. Такой тест позволяет быстрое обнаружение серьезных проблем, экономию времени и ресурсов, фокусировку на ключевых аспектах системы и позитивную оценку ее работоспособности перед другими этапами тестирования.

Процесс проведения смоук-тестирования

Этапы проведения смоук-тестирования:

1. 1\.Идентификация основных функциональных блоков или компонентов системы.

2. 2\.Определение критических путей или ключевых сценариев использования.

3. 3\.Создание смоук-тестовых кейсов, которые проверяют основные функции каждого блока или компонента.

4. 4\.Запуск смоук-тестов и наблюдение за их результатами.

5. 5\.Анализ результатов и выявление любых критических проблем или отклонений.

6. 6\.Документирование результатов и принятие решения о дальнейших шагах.

Пример smoke testing:

Предположим, в тестируемом приложении есть следующие основные пользовательские сценарии:

-  Вход в систему

-  Регистрация пользователя

-  Личная страница пользователя

-  Редактирование личных данных

Для такого приложения тестировщик в ходе Smoke-тестирования должен проверить все основные пользовательские сценарии. Например:

-  Пользователь смог войти с действительными учетными данными.

-  Пользователь не смог войти c недействительными учетными данными.

-  Успешное создание нового пользователя при заполнении формы регистрации валидными данными.

-  Просмотр страницы пользователя после входа в систему.

-  Пользователь смог отредактировать Имя/email

Преимущества Smoke-тестирования

-  Простота выполнения тестирования;

-  Обнаружение дефектов на ранних этапах;

-  Повышение качества системы;

-  Экономия времени и ресурсов при тестировании;

-  Минимизация рисков интеграции.

Заключение

Таким образом, Smoke-тестирование или проверка сборки проводится для того, чтобы до запуска продукта убедиться, что всё работает стабильно и отвечает требованиям заказчика. Оно проводится при каждой новой сборке. У дымового тестирования много преимуществ: оно помогает заметить дефекты на раннем этапе, повысить качество системы и экономит время команды.



### Ре-рест функционала

Re-test и Defect Validation

Re-test

Определение: Re-test -- это процесс повторного тестирования той же функциональности после исправления дефекта, чтобы убедиться, что проблема действительно решена.

Пример: Представьте, что у вас в приложении был баг, из-за которого кнопка "Отправить" не работала. После исправления разработчиками, вы снова тестируете эту кнопку, чтобы убедиться, что теперь она работает. Это и есть Re-test.

Источник: В соответствии с ISTQB, Re-test (повторное тестирование) относится к процессу повторного выполнения тестов, которые ранее провалились, чтобы убедиться, что ошибки были исправлены и ранее некорректный функционал теперь работает как ожидалось (ISTQB).

Defect Validation

-  Определение: Defect Validation -- это процесс подтверждения того, что исправленный дефект больше не воспроизводится, а связанные с ним области системы не нарушены.

-  Пример: После успешного Re-test, нужно убедиться, что исправление не повлияло на другие функции приложения, например, другие кнопки продолжают работать корректно.

-  Источник: В материалах Куликова упоминается, что Defect Validation важен для подтверждения качества фикса и предотвращения потенциальных регрессий (Куликов).

#### Когда и зачем использовать?

Когда использовать:

-  После фиксации дефекта разработчиками: Когда программист фиксирует баг, необходимо провести Re-test, чтобы убедиться в исправлении.

-  Перед завершением тестирования: Перед финальным релизом продукта обязательно выполняется Defect Validation, чтобы убедиться в отсутствии критических ошибок.

-  Источник: ISTQB подчеркивает, что Re-test и Defect Validation проводятся после устранения дефекта, чтобы проверить его исправление и стабильность системы в целом (ISTQB).

Зачем использовать:

-  Повышение качества продукта: Регулярное проведение этих процессов помогает обеспечить, что все исправления внедрены правильно и система работает стабильно.

-  Предотвращение возврата дефектов: Эти процедуры снижают риск возвращения уже исправленных ошибок, что положительно влияет на общую стабильность системы.

-  Источник: Как отмечено в материалах Куликова, один из главных рисков при отсутствии Defect Validation -- это возможность возникновения новых дефектов из-за изменений в коде (Куликов).

#### Ключевые моменты

Цель: Подтверждение исправления дефектов.

-  Re-test: Вы повторно тестируете фиксированный элемент, чтобы убедиться, что он теперь работает как нужно.

-  Defect Validation: Вы проверяете, что этот фикс не повлиял негативно на другие части системы.

Процесс:

1. 1\.Идентификация исправленных дефектов: Определите, какие баги были исправлены.

2. 2\.Повторное тестирование (Re-test): Проведите тесты, которые ранее не прошли, чтобы убедиться, что баг исправлен.

3. 3\.Проверка на отсутствие регрессий (Defect Validation): Убедитесь, что исправление не вызвало новых багов.

Риски:

-  Неполное тестирование: Если Re-test не проводится тщательно, дефект может остаться не исправленным.

-  Риски регрессий: Исправление одного дефекта может повлиять на другие части системы, создавая новые баги.

В материалах Куликова и ISTQB говорится о важности тщательного тестирования после фикса дефектов для предотвращения регрессий и других ошибок (ISTQB, Куликов).



### Санитарное (Sanity) тестирование

Sanity testing (санитарное тестирование) -- это тип тестирования, который выполняется для проверки того, что определенные функции или изменения в программном обеспечении работают как ожидается после внесения изменений, таких как исправления ошибок или обновления. Основная цель санитарного тестирования -- быстро определить, не нарушили ли внесенные изменения основные функции приложения.

Основные характеристики sanity testing:

Цель: Проверка конкретных функциональных аспектов приложения для подтверждения, что изменения не вызвали новых проблем.

Область тестирования: Обычно охватывает небольшую часть функциональности, которая была изменена или затронута.

Выполнение: Выполняется после регрессионного тестирования, чтобы удостовериться, что исправления ошибок или новые функции работают корректно.

Скорость: Обычно это быстрое тестирование, которое не требует полного тестирования всего приложения.

Пример: Если в приложении была исправлена ошибка в функции авторизации, sanity testing может включать проверку, что пользователи могут успешно войти в систему с правильными учетными данными и что ошибка больше не возникает.

Sanity testing помогает быстро удостовериться в работоспособности системы после изменений, что позволяет сэкономить время и ресурсы на более глубокое тестирование.



### Тестирование нового функционала (New future testing)

New Feature Testing (тестирование новых функций) -- это процесс проверки и валидации новых функций или возможностей, добавленных в программное обеспечение. Цель этого тестирования -- убедиться, что новые функции работают как задумано и соответствуют требованиям, прежде чем они будут выпущены пользователям.

Основные аспекты New Feature Testing:

Цель: Проверка функциональности, производительности и совместимости новых функций с существующей системой.

Подходы:

Функциональное тестирование: Проверка, что новая функция выполняет заявленные задачи.

Нефункциональное тестирование: Оценка производительности, безопасности и удобства использования новой функции.

Этапы:

Анализ требований: Изучение спецификаций и требований к новой функции.

Разработка тестовых случаев: Создание тестовых сценариев, охватывающих все аспекты новой функции.

Выполнение тестов: Проведение тестирования для выявления ошибок и несоответствий.

Отчетность: Документирование результатов тестирования и передача их команде разработки для исправления обнаруженных проблем.

Инструменты: Используются различные инструменты для автоматизации тестирования новых функций, такие как Selenium, JUnit, TestNG и другие.

Важность: Тестирование новых функций помогает предотвратить появление ошибок в продуктивной среде, улучшает качество продукта и повышает удовлетворенность пользователей.



### Регрессионное (Regression) тестирование

Что такое Regression Testing?

Regression Testing (регрессионное тестирование) -- это процесс повторного тестирования программного обеспечения после изменений, таких как добавление новой функции, исправление ошибок или обновление системы. Основная цель -- убедиться, что изменения не нарушили работу уже существующего функционала. Как описано в ISTQB, регрессионное тестирование направлено на проверку того, что модификации в ПО не привели к появлению новых дефектов .

Почему это важно?

Когда программисты вносят изменения в код, есть риск непреднамеренно «сломать» уже работающие функции. Например, после исправления одного бага может появиться другой. Регрессионное тестирование помогает выявить такие ошибки на раннем этапе. Куликов в своей книге подчеркивает важность регрессионного тестирования как ключевого инструмента для поддержания стабильности ПО после изменений .

Когда выполняется Regression Testing?

Перед выпуском новой версии:

Регрессионное тестирование обязательно проводится перед релизом новой версии продукта. Это позволяет убедиться, что все изменения и новые функции интегрированы без проблем. Как отмечает ISTQB, перед выпуском особенно важно убедиться, что нет критических багов, влияющих на пользователя .

После исправления багов:

Когда баг исправлен, нужно проверить не только его устранение, но и то, что это исправление не вызвало других проблем. Куликов отмечает, что регрессионное тестирование после багфиксов важно для поддержания стабильности продукта .

После добавления новых функций:

Новые функции могут оказать неожиданное влияние на старый функционал, даже если они кажутся независимыми. Поэтому важно провести регрессионное тестирование, чтобы проверить работу всего продукта после добавления новшеств .

Методы проведения Regression Testing

Полное тестирование:

Полный цикл регрессионного тестирования включает проверку всех функций системы. Это надежный, но трудоемкий подход, требующий значительных ресурсов. Как отмечает Куликов, такой метод используется редко из-за его высокой стоимости, но в критически важных системах он необходим .

Частичное тестирование:

Частичное регрессионное тестирование фокусируется на тех частях системы, которые были затронуты изменениями. Это более быстрый и экономичный подход, особенно если нужно протестировать большой продукт. Как описано в ISTQB, этот метод снижает затраты на тестирование и время на выполнение .

Автоматизация:

Автоматизация регрессионного тестирования значительно ускоряет процесс. Автоматические тесты могут запускаться каждый раз после изменения кода, что уменьшает количество ошибок, которые могут быть пропущены. Как подчеркивается в работе Куликова, автоматизация является ключевым элементом для эффективного регрессионного тестирования в современных разработках .

Ключевые преимущества Regression Testing

Улучшение качества продукта:

Регрессионное тестирование гарантирует, что продукт сохраняет высокое качество даже после множества изменений. Как отмечают в ISTQB, это важно для повышения доверия к продукту со стороны пользователей и команды разработки .

Снижение рисков:

Регулярное проведение регрессионного тестирования помогает уменьшить риски неожиданного появления багов, что повышает стабильность и надежность системы .

Экономия времени и ресурсов:

Использование автоматизированного регрессионного тестирования позволяет сэкономить время, необходимое для тестирования, и сократить человеческие ошибки. По данным Куликова, это особенно важно для крупных проектов с частыми обновлениями .



### Приемочное тестирование (User acceptance testing)

User Acceptance Testing (UAT)

 User Acceptance Testing, или тестирование на приемлемость пользователем, -- это последний этап перед выпуском продукта, где реальные пользователи проверяют его соответствие их ожиданиям и требованиям. Важно понять, что UAT -- это не просто поиск багов. Главная цель -- удостовериться, что продукт работает так, как ожидают конечные пользователи, и удовлетворяет их бизнес-потребности.

Согласно ISTQB, UAT -- это вид тестирования, который проводится пользователями и заинтересованными сторонами для подтверждения того, что система работает как ожидалось в реальной рабочей среде.

В книгах Куликова говорится, что UAT позволяет обнаружить проблемы, которые не были замечены ранее, так как пользователи видят продукт с другого ракурса, нежели разработчики.

#### Цель UAT

Подтверждение соответствия: Цель UAT -- убедиться, что система соответствует заявленным требованиям и ожиданиям пользователей. Это последний шанс для пользователей удостовериться, что продукт готов к внедрению. Например, если это система для учета заказов, пользователи проверяют, насколько удобно и правильно она работает в рамках их ежедневных задач.

Выявление ошибок: В ходе UAT пользователи могут обнаружить баги или несоответствия, которые не были выявлены на предыдущих этапах тестирования. Эти ошибки могут быть связаны с тем, как система работает в реальных условиях. Даже если технически система работает правильно, пользователь может найти что-то неудобное или непонятное.

-  ISTQB подчеркивает, что UAT проводится для снижения рисков после выпуска продукта и подтверждения его готовности к использованию.

-  Куликов отмечает, что UAT часто помогает обнаружить проблемы с удобством использования, которые могли быть упущены на этапах тестирования функциональности.

#### Процесс проведения UAT

Определение сценариев: Перед началом UAT пользователи создают тестовые сценарии, основанные на реальных задачах и процессах, с которыми они сталкиваются ежедневно. Например, сценарий может включать процесс оформления заказа, проверки его статуса и выполнения возврата. Эти сценарии должны отражать самые важные функции, которые необходимы пользователям для их работы.

Тестирование: Пользователи начинают тестирование, выполняя созданные сценарии в системе. Если они обнаруживают ошибки или что-то, что не соответствует их ожиданиям, они фиксируют это и сообщают разработчикам. Важно отметить, что это тестирование проводится в реальной рабочей среде, что помогает выявить потенциальные проблемы, которые могут не проявиться в других условиях.

Обратная связь: После завершения тестирования пользователи обсуждают результаты с командой разработки. Если обнаружены критические ошибки или несоответствия, они должны быть исправлены перед выпуском продукта. Это обеспечивает, что на этапе релиза система будет полностью соответствовать ожиданиям пользователей.

-  Согласно ISTQB, процесс UAT включает в себя планирование, выполнение и оценку результатов тестирования, а также принятие решения о готовности продукта к релизу.

-  В книгах Куликова говорится, что хорошо проведенный UAT позволяет избежать множества проблем после внедрения системы, так как пользователи чувствуют себя уверенными в продукте.

Подтверждение готовности: Если продукт успешно прошел UAT, это означает, что пользователи подтвердили его соответствие их требованиям, и он готов к релизу. Важно отметить, что успешное прохождение UAT является зеленым светом для выпуска продукта на рынок или его внедрения в рабочий процесс.

Снижение рисков: Проведение UAT помогает существенно снизить риски, связанные с неудовлетворенностью пользователей после выпуска продукта. Это особенно важно в крупных проектах, где сбои или ошибки могут привести к серьезным финансовым потерям или нарушению бизнес-процессов.

-  ISTQB отмечает, что UAT позволяет снизить риски неудовлетворенности пользователей и уменьшить количество доработок после релиза.

-  Куликов добавляет, что успешный UAT повышает доверие пользователей к продукту и снижает вероятность отказа от его использования.

## По разработке тестовых сценариев

### На основе требований

Тестирование на основе требований ориентировано на проверку соответствия программного обеспечения формализованным требованиям, предъявленным к нему. Этот вид тестирования направлен на проверку того, что каждая функциональность, описанная в спецификации требований, была реализована правильно и соответствует ожиданиям.

**Преимущества:**

Полнота проверки: Каждый аспект системы проверяется на соответствие четко определенным требованиям.

Ясность и прослеживаемость: Легко проследить, как каждое требование было проверено.

**Недостатки:**

Зависимость от качества требований: Если требования нечеткие или неполные, тестирование может быть неэффективным.

Трудоемкость: Анализ и разработка тестов для всех требований может занять много времени и усилий

**Пример:**

В системе онлайн-банкинга может существовать требование, что все финансовые транзакции должны быть подтверждены двухфакторной аутентификацией. Тестирование на основе требований будет включать проверку выполнения этого требования во всех возможных сценариях использования.



### По вариантам использования

Тестирование по вариантам использования (Use Case Testing)

Тестирование по вариантам использования ориентировано на проверку того, как система будет использоваться пользователями. Оно включает разработку сценариев на основе реальных случаев использования системы (use cases), описывающих последовательность действий, выполняемых пользователем для достижения определенной цели.

**Преимущества:**

Ориентация на пользователя: Тестирование на основе сценариев использования помогает убедиться, что система действительно удовлетворяет потребности пользователей.

Покрытие реальных сценариев: Тестирование охватывает реальные пути использования системы, что снижает риск упущения критичных для пользователя функций.

**Недостатки:**

Неохват всех возможных сценариев: Варианты использования обычно не охватывают все возможные ошибки или исключения.

Требуется хорошее понимание пользователя: Успешное тестирование по сценариям использования требует глубокого понимания пользовательских требований и поведения.

**Пример:**

Для интернет-магазина можно создать сценарий использования, который включает поиск товара, добавление его в корзину, оформление заказа и оплату. Тестирование должно убедиться, что все эти шаги выполняются корректно.

### На основе модели

Тестирование на основе моделей использует модели системы для генерации тестовых сценариев. Эти модели могут представлять собой диаграммы состояний, диаграммы потоков данных или другие формальные описания поведения системы.

**Преимущества:**

Автоматизация: Модели позволяют автоматизировать процесс создания тестов, что повышает эффективность тестирования.

Покрытие: Модель может обеспечить более полное покрытие возможных путей выполнения программы.

**Недостатки:**

Сложность: Создание и поддержка моделей может быть сложным и трудоемким процессом.

Зависимость от модели: Если модель не отражает всех аспектов системы, тестирование может быть неполным.

**Пример:**

Для системы управления трафиком можно создать модель, которая описывает, как светофоры должны менять свои состояния (зеленый, желтый, красный) в зависимости от времени суток и потока автомобилей. Тестирование будет проверять, правильно ли система переключает светофоры в соответствии с моделью.

#### Когда использовать:

Тестирование на основе требований подходит для проектов, где имеются четко определенные требования, и нужно убедиться, что они полностью реализованы.

Тестирование по вариантам использования применяется, когда важно убедиться, что система поддерживает ключевые сценарии использования, особенно с точки зрения пользователя.

Тестирование на основе моделей эффективно, когда необходимо автоматизировать процесс тестирования и охватить сложные взаимодействия и состояния системы.


## По степени автоматизации

### Ручное

Ручное тестирование (manual testing) -- часть процесса тестирования на этапе контроля качества в процессе разработки программного обеспечения. Оно производится тестировщиком без использования программных средств, для проверки программы или сайта путём моделирования действий пользователя. В роли тестировщиков могут выступать и обычные пользователи, сообщая разработчикам о найденных ошибках.

Преимущества ручного тестирования

· Человеческий интеллект: ручной процесс тестирования требует конкретных навыков для разработки тестовых сценариев, выявления неисправностей и оценки качества продукта в целом. Для проверки удобства использования, производительности и функциональности ПО инженеры используют свои знания в данной области, накопленный опыт и изобретательность.

· Адаптивность: ручное тестирование легко адаптируется под разные условия проекта и может использоваться в любых стратегиях тестирования. Инженеры могут менять тестовые сценарии при необходимости, в отличие от автоматизированного тестирования, стратегию которого не так легко изменить. Кроме того, вручную можно проводить исследовательское тестирование, которое несёт пользу для выявления новых проблем и оценки пользовательского опыта.

· Экономическая выгода: ручное тестирование -- экономически выгодно, особенно для небольших проектов или при отсутствии чёткого понимания требований к сайту, мобильному приложению, базе данных и другому ПО. Ручное тестирование не требует инвестиций в дорогостоящие инструменты или средства автоматизации, что позволяет существенно снизить затраты тестирование продукта.

· Индивидуальный подход: автоматизированное тестирование в отличие от ручного не способно фиксировать комментарии тестировщиков об удобстве использования, дизайне и пользовательском опыте решения. Эти комментарии помогают разработчикам улучшить функциональность, вёрстку.

· Раннее обнаружение дефектов: с помощью ручного тестирования возможно на ранних этапах разработки обнаружить серьёзные дефекты. Тестирование вручную проводят люди, что позволяет им находить ошибки, которые автоматизированное тестирование могло бы пропустить. Предотвращая дорогостоящую доработку на более поздних этапах создания ПО, раннее обнаружение дефектов сокращает время и расходы на цикл разработки.

· Относительная простота: для реализации требуемого числа итераций в рамках ручного тестирования несложно подобрать подходящих специалистов и привлечь их на проект в сжатые сроки.

Недостатки ручного тестирования

· Время на выполнение тестов: ручное тестирование требует времени, поскольку тестовые примеры выполняются вручную. Особенно это касается тестирования сложных модулей. Из-за установленных дедлайнов команда тестирования может не успеть проверить все тестовые сценарии.

· Человеческие ошибки: при проведении тестирования вручную возможны человеческие ошибки. Не сумев протестировать определённые сценарии или допустив ошибки при выполнении тестовых случаев, тестировщики могут получить ошибочные результаты. Это затруднит поиск дефектов, которые могут повлиять на качество продукта.

· Сложность измерения результата: количественная оценка результатов процесса ручного тестирования возможна, но она требует высоких навыков управления, организационных мероприятий и временных затрат.

### Автоматизированное

Автоматизированное тестирование (automated testing, test automation) - набор техник, подходов и инструментальных средств, позволяющий исключить человека из выполнения некоторых задач в процессе тестирования.

Области применения автоматизации:

· Регрессионное тестирование: необходимость выполнять вручную тесты, количество которых неуклонно растет с каждым билдом, но вся суть которых сводится к проверке того факта, что ранее работавшая функциональность продолжает работать корректно.

· Инсталляционное тестирование и настройка тестового окружения: множество часто повторяющихся рутинных операций по проверке работы инсталлятора, размещения файлов в файловой системе, содержимого конфигурационных файлов, реестра и т.д. Подготовка приложения в заданной среде и с заданными настройками для проведения основного тестирования.

· Конфигурационное тестирование и тестирование совместимости: выполнение одних и тех же тест-кейсов на большом множестве входных данных, под разными платформами и в разных условиях. Классический пример: есть файл настроек, в нём сто параметров, каждый может принимать сто значений: существует 100^100 вариантов конфигурационного файла - все их нужно проверить.

· Использование комбинаторных техник тестирования (в т.ч. доменного тестирования): генерация комбинаций значений и многократное выполнение тест-кейсов с использованием этих сгенерированных комбинаций в качестве входных данных.

· Модульное тестирование: проверка корректности работы атомарных участков кода и элементарных взаимодействий таких участков кода - практически невыполнимая для человека задача при условии, что нужно выполнить тысячи таких проверок и нигде не ошибиться.

· Интеграционное тестирование: глубокая проверка взаимодействия компонентов в ситуации, когда человеку почти нечего наблюдать, т.к. все представляющие интерес и подвергаемые тестированию процессы проходят на уровнях более глубоких, чем пользовательский интерфейс.

· Тестирование безопасности: необходимость проверки прав доступа, паролей по умолчанию, открытых портов, уязвимостей текущих версий ПО и т.д., т.е. быстрое выполнение очень большого количества проверок, в процессе которого нельзя что-то пропустить, забыть или «не так понять».

· Тестирование производительности: создание нагрузки с интенсивностью и точностью, недоступной человеку. Сбор с высокой скоростью большого набора параметров работы приложения. Анализ большого объема данных из журналов работы системы автоматизации.

· Дымовой тест для крупных систем: выполнение при получении каждого билда большого количества достаточно простых для автоматизации тест-кейсов.

· Приложения (или их части) без графического интерфейса: проверка консольных приложений на больших наборах значений параметров командной строки (и их комбинаций). Проверка приложений и их компонентов, вообще не предназначенных для взаимодействия с человеком (веб-сервисы, серверы, библиотеки и т.д.).

· Длительные, рутинные, утомительные для человека и/или требующие повышенного внимания операции: проверки, требующие сравнения больших объёмов данных, высокой точности вычислений, обработки большого количества размещенных по всему дереву каталогов файлов, ощутимо большого времени выполнения и т.д. Особенно, когда такие проверки повторяются очень часто.

· Проверка «внутренней функциональности» веб приложений (ссылок, доступности страниц и т.д.): автоматизация предельно рутинных действий (например, проверить все 30’000+ ссылок на предмет того, что все они ведут на реально существующие страницы). Автоматизация здесь упрощается в силу стандартности задачи - существует много готовых решений.

· Стандартная, однотипная для многих проектов функциональность: даже высокая сложность при первичной автоматизации в таком случае окупится за счёт простоты многократного использования полученных решений в разных проектах.

· “Технические задачи”: проверки корректности протоколирования, работы с базами данных, корректности поиска, файловых операций, корректности форматов и содержимого генерируемых документов и т.д.

Какие модули и места следует автоматизировать?

· Участки кода, выполнение которых трудно визуализировать и получить четкую информацию о процессах (например, back-end процессы, запись в базу данных, сохранение логов в файл);

· Функциональность продукта, которая часто используется и связана с высоким риском ошибок. Автоматизация тестирования таких узлов позволит быстрее обнаруживать ошибки и, соответственно, быстрее их устранять;

· Работа с типовыми операциями, такими как создание, чтение, обновление и удаление данных (CRUD). Например, формы с большим количеством полей. Цель - автоматизировать ввод данных и проверить правильность результатов;

· Обработка сообщений об ошибках. Необходима автоматизация обработки некорректных данных и проверки сообщений об ошибках;

· Комплексное тестирование всей системы, чтобы проверить ее работу как единого целого (end-to-end testing);

· Проверка числовых массивов, которые используются для математических операций;

· Проверка корректности отображения результатов поиска по нужным данным;

· Проверка функциональности, связанной с безопасностью приложения, такая как проверка наличия уязвимостей веб-приложения;

· Автоматизированное тестирование процессов масштабирования и управления ресурсами, таких как процессы добавления и удаления серверов из кластера;

· Тестирование производительности, включая оценку времени выполнения операций и реакции системы на нагрузку;

· Проверка совместимости с различными платформами и устройствами, таких как разные браузеры, операционные системы и мобильные устройства.

Преимущества автоматизации:

· Скорость выполнения тест-кейсов может в разы и на порядки превосходить возможности человека. Если представить, что человеку придётся вручную сверять несколько файлов размером в несколько десятков мегабайт каждый, оценка времени ручного выполнения становится пугающей: месяцы или даже годы. При этом 36 проверок, реализуемых в рамках дымового тестирования командными скриптами, выполняются менее чем за пять секунд и требуют от тестировщика только одного действия - запустить скрипт;

· Отсутствует влияние человеческого фактора в процессе выполнения тест кейсов (усталости, невнимательности и т.д.). Продолжим пример из предыдущего пункта: какова вероятность, что человек ошибется, сравнивая (посимвольно!) даже два обычных текста размером в 100 страниц каждый? А если таких текстов 10? 20? И проверки нужно повторять раз за разом? Можно смело утверждать, что человек ошибется гарантированно. Автоматика не ошибется;

· Средства автоматизации способны выполнить тест-кейсы, в принципе непосильные для человека в силу своей сложности, скорости или иных факторов. И снова наш пример со сравнением больших текстов является актуальным: мы не можем позволить себе потратить годы, раз за разом выполняя крайне сложную рутинную операцию, в которой мы к тому же будем гарантированно допускать ошибки. Другим прекрасным примером непосильных для человека тест-кейсов является исследование производительности, в рамках которого необходимо с высокой скоростью выполнять определённые действия, а также фиксировать значения широкого набора параметров. Сможет ли человек, например, сто раз в секунду измерять и записывать объем оперативной памяти, занимаемой приложением? Нет. Автоматика сможет;

· Средства автоматизации способны собирать, сохранять, анализировать, агрегировать и представлять в удобной для восприятия человеком форме колоссальные объемы данных. В нашем примере с дымовым тестированием «Конвертера файлов» объем данных, полученный в результате тестирования, невелик - его вполне можно обработать вручную. Но если обратиться к реальным проектным ситуациям, журналы работы систем автоматизированного тестирования могут занимать десятки гигабайт по каждой итерации. Логично, что человек не в состоянии вручную проанализировать такие объёмы данных, но правильно настроенная среда автоматизации сделает это сама, предоставив на выход аккуратные отчеты в 2-3 страницы, удобные графики и таблицы, а также возможность погружаться в детали, переходя от агрегированных данных к подробностям, если в этом возникнет необходимость;

· Средства автоматизации способны выполнять низкоуровневые действия с приложением, операционной системой, каналами передачи данных и т.д. В одном из предыдущих пунктов мы упоминали такую задачу, как «сто раз в секунду измерить и записать объем оперативной памяти, занимаемой приложением». Подобная задача сбора информации об используемых приложением ресурсах является классическим примером. Однако средства автоматизации могут не только собирать подобную информацию, но и воздействовать на среду исполнения приложения или само приложение, эмулируя типичные события (например, нехватку оперативной памяти или процессорного времени) и фиксируя реакцию приложения. Даже если у тестировщика будет достаточно квалификации, чтобы самостоятельно выполнить подобные операции, ему всё равно понадобится то или иное инструментальное средство - так почему не решить эту задачу сразу на уровне автоматизации тестирования?

Недостатки автоматизации:

· Необходимость наличия высококвалифицированного персонала в силу того факта, что автоматизация - это «проект внутри проекта» (со своими требованиями, планами, кодом и т.д.). Даже если забыть на мгновение про «проект внутри проекта», техническая квалификация сотрудников, занимающихся автоматизацией, как правило, должна быть ощутимо выше, чем у их коллег, занимающихся ручным тестированием.

· Разработка и сопровождение как самих автоматизированных тест-кейсов, так и всей необходимой инфраструктуры занимает очень много времени. Ситуация усугубляется тем, что в некоторых случаях (при серьёзных изменениях в проекте или в случае ошибок в стратегии) всю соответствующую работу приходится выполнять заново с нуля: в случае ощутимого изменения требований, смены технологического домена, переработки интерфейсов (как пользовательских, так и программных) многие тест-кейсы становятся безнадежно устаревшими и требуют создания заново.

· Автоматизация требует более тщательного планирования и управления рисками, т.к. в противном случае проекту может быть нанесен серьезный ущерб (см. предыдущий пункт про переделку с нуля всех наработок).

· Коммерческие средства автоматизации стоят ощутимо дорого, а имеющиеся бесплатные аналоги не всегда позволяют эффективно решать поставленные задачи. И здесь мы снова вынуждены вернуться к вопросу ошибок в планировании: если изначально набор технологий и средств автоматизации был выбран неверно, придётся не только переделывать всю работу, но и покупать новые средства автоматизации.

· Средств автоматизации крайне много, что усложняет проблему выбора того или иного средства, затрудняет планирование и определение стратегии тестирования, может повлечь за собой дополнительные временные и финансовые затраты, а также необходимость обучения персонала или найма соответствующих специалистов.

### Смешанное/Полуавтоматизированное тестирование

Смешанное или полуавтоматизированное тестирование -- это метод тестирования, в котором используется сочетание ручного и автоматизированного подходов. Оно позволяет использовать сильные стороны обоих методов, что делает процесс тестирования более гибким и эффективным.

#### Особенности:

-  **Ручное тестирование**: Задействовано для тех частей продукта, которые требуют анализа, субъективной оценки или работы с пользовательским интерфейсом, где автоматизация может оказаться сложной или нецелесообразной.

-  **Автоматизированное тестирование**: Используется для рутинных задач или тех аспектов, где требуется регулярное повторение (регрессионное тестирование, стресс-тесты, проверка производительности и т. д.). Автоматизированные тесты выполняются быстрее и позволяют тестировать большие объемы данных.

#### Примеры использования:

1. **Регрессионное тестирование**: Автоматизируются основные сценарии, а ручное тестирование применяется для сложных или новых функций.

2. **UI тесты**: Некоторые интерфейсы могут требовать ручной проверки, чтобы учесть человеческий фактор (удобство использования, визуальные баги), но автоматизированные тесты могут покрывать функциональные проверки взаимодействия с UI.

3. **Тестирование API**: Основная часть тестов может быть автоматизирована, но сложные случаи, где требуется проверить специфические интеграции или сценарии, могут проверяться вручную.

#### Преимущества:

-  Экономия времени на рутинных задачах.

-  Возможность глубже проработать критические сценарии вручную.

-  Более высокая вероятность выявления ошибок, которые могли бы быть пропущены при исключительно автоматизированном или ручном тестировании.

#### Ограничения:

-  Требует больших усилий для разработки и поддержки тестов (автоматизированных сценариев).

-  Может быть сложнее синхронизировать процессы ручного и автоматизированного тестирования, особенно в больших командах.








